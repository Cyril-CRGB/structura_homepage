<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Title for the page -->
    <title>Interactive 27-Cube Design</title>
    <!-- Include the Three.js library for 3D graphics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Styling for the page and canvas container -->
    <style>
        /* Basic body styling */
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #f8f6f0, #ffffff);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }

        /* Container for the 3D canvas */
        .canvas-container {
            width: 1024px;
            height: 1024px;
            position: relative;
            background: linear-gradient(135deg, #f0f0f0, #e0e0e0);
            overflow: hidden;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        /* Styling for the canvas element where the animation will be rendered */
        #cube-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <!-- The main container for the 3D animation -->
    <div class="canvas-container">
        <canvas id="cube-canvas"></canvas>
    </div>

    <script>
        /**
         * A class to create and animate a 3x3x3 cube structure like a Rubik's Cube.
         */
        class RubiksCube {
            constructor() {
                // Set up the basic Three.js components: scene, camera, and renderer
                this.scene = new THREE.Scene();
                // Use a perspective camera. Aspect ratio is 1 because the canvas is square.
                this.camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('cube-canvas'),
                    alpha: true, // Allows for a transparent background
                    antialias: true // Smooths the edges of the cubes
                });
                this.renderer.setSize(1024, 1024); // Set to the container's dimensions
                this.renderer.shadowMap.enabled = true; // Enable shadows
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                this.cubes = []; // Array to hold all the individual cube objects
                this.unit = 1.0; // The size of a cube plus its gap

                this.init();
            }

            /**
             * Initializes the cube, sets up lighting, creates the geometry,
             * and starts the animation sequences.
             */
            init() {
                this.camera.position.set(8, 8, 8);
                this.camera.lookAt(0, 0, 0);

                // Define the color palette based on the original CSS file
                this.colors = [
                    0xD03C4B, // color-1: Red
                    0x3FB6F0, // color-2: Blue
                    0xF75759, // color-3: Light Red
                    0x083F67, // color-4: Dark Blue
                    0xf2f2f2, // color-5: Light Grey
                    0xd9d9d9, // color-6: Grey
                    0x2e2a2a  // color-7: Dark Grey/Black
                ];

                this.createCube();
                this.setupLighting();
                this.applyScramble(); // Instantly scramble the cube
                this.spinSolveThenRevert(); // Start the animation sequence
                this.startAnimation();
            }

            /**
             * Creates the 27 individual cubes and positions them in a 3x3x3 grid.
             */
            createCube() {
                const cubeGroup = new THREE.Group();
                const size = 0.95; // The size of each small cube
                const gap = 0.05;  // The gap between cubes

                for (let x = -1; x <= 1; x++) {
                    for (let y = -1; y <= 1; y++) {
                        for (let z = -1; z <= 1; z++) {
                            // The center cube is not created to leave the core empty if desired
                            if (x === 0 && y === 0 && z === 0) continue;

                            const geometry = new THREE.BoxGeometry(size, size, size);
                            // Assign a random color from the palette to each face
                            const materials = this.colors.map(c => new THREE.MeshLambertMaterial({ color: c }));

                            const mesh = new THREE.Mesh(geometry, materials);
                            mesh.position.set(x * (size + gap), y * (size + gap), z * (size + gap));
                            mesh.castShadow = true;
                            mesh.receiveShadow = true;

                            cubeGroup.add(mesh);
                            this.cubes.push({
                                mesh: mesh,
                                currentPosition: [x, y, z] // Store its logical position
                            });
                        }
                    }
                }

                this.scene.add(cubeGroup);
                this.cubeGroup = cubeGroup;
            }

            /**
             * Sets up the lighting for the scene.
             */
            setupLighting() {
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
            }

            /**
             * Instantly applies a sequence of rotations to scramble the cube without animation.
             */
            applyScramble() {
                const scrambleSeq = [
                    { type: 'vertical',   layer: -1, degrees: 90 },
                    { type: 'horizontal', layer: -1, degrees: 180 },
                    { type: 'vertical',   layer:  0, degrees: 270 },
                    { type: 'vertical',   layer:  1, degrees: 90 },
                    { type: 'horizontal', layer:  1, degrees: 180 }
                ];

                scrambleSeq.forEach(move => {
                    if (move.type === 'vertical') {
                        this.applyRotation('x', move.layer, move.degrees);
                    } else {
                        this.applyRotation('y', move.layer, move.degrees);
                    }
                });
            }

            /**
             * Helper function to apply an instant rotation to a layer of cubes.
             * @param {string} axis - 'x' for vertical, 'y' for horizontal.
             * @param {number} layer - The layer to rotate (-1, 0, or 1).
             * @param {number} degrees - The degrees to rotate.
             */
            applyRotation(axis, layer, degrees) {
                const radians = degrees * Math.PI / 180;
                const axisIndex = (axis === 'x') ? 0 : 1;
                const cubesToRotate = this.cubes.filter(c => c.currentPosition[axisIndex] === layer);
                
                const tempGroup = new THREE.Group();
                this.scene.add(tempGroup);
                cubesToRotate.forEach(cubeObj => tempGroup.attach(cubeObj.mesh));
                
                tempGroup.rotation[axis] += radians;
                tempGroup.updateMatrixWorld();

                cubesToRotate.forEach(cubeObj => {
                    this.cubeGroup.attach(cubeObj.mesh); // Re-attach to main group
                    
                    const newPos = new THREE.Vector3();
                    cubeObj.mesh.getWorldPosition(newPos);

                    // Snap positions to the grid
                    const snappedPos = [
                        Math.round(newPos.x / this.unit),
                        Math.round(newPos.y / this.unit),
                        Math.round(newPos.z / this.unit)
                    ];
                    
                    cubeObj.currentPosition = snappedPos;
                    cubeObj.mesh.position.set(snappedPos[0] * this.unit, snappedPos[1] * this.unit, snappedPos[2] * this.unit);
                });
                this.scene.remove(tempGroup);
            }

            /**
             * Animates a rotation for a specific layer.
             * @param {string} axis - The axis of rotation ('x' or 'y').
             * @param {number} layer - The layer to rotate (-1, 0, or 1).
             * @param {number} degrees - The angle of rotation.
             * @param {number} duration - The duration of the animation in ms.
             * @param {function} onComplete - Callback function to execute when animation is done.
             */
            animateLayerRotation(axis, layer, degrees, duration, onComplete) {
                const radians = degrees * Math.PI / 180;
                const axisIndex = (axis === 'x') ? 0 : 1;
                const cubesToRotate = this.cubes.filter(c => c.currentPosition[axisIndex] === layer);
                
                const tempGroup = new THREE.Group();
                this.scene.add(tempGroup);
                cubesToRotate.forEach(cubeObj => tempGroup.attach(cubeObj.mesh));

                const startRot = tempGroup.rotation[axis];
                const targetRot = startRot + radians;
                const startTime = performance.now();

                const animate = () => {
                    const elapsed = performance.now() - startTime;
                    let t = Math.min(elapsed / duration, 1);
                    t = 0.5 - 0.5 * Math.cos(Math.PI * t); // Ease in-out
                    tempGroup.rotation[axis] = startRot + (targetRot - startRot) * t;

                    if (t < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        tempGroup.updateMatrixWorld();
                        // When animation finishes, re-attach cubes to the main group and update positions
                        cubesToRotate.forEach(cubeObj => {
                            this.cubeGroup.attach(cubeObj.mesh);

                            const newPos = new THREE.Vector3();
                            cubeObj.mesh.getWorldPosition(newPos);
                            
                            const snappedPos = [
                                Math.round(newPos.x / this.unit),
                                Math.round(newPos.y / this.unit),
                                Math.round(newPos.z / this.unit)
                            ];

                            cubeObj.currentPosition = snappedPos;
                            cubeObj.mesh.position.set(snappedPos[0] * this.unit, snappedPos[1] * this.unit, snappedPos[2] * this.unit);
                            // Reset local rotation after attaching to preserve orientation
                            cubeObj.mesh.rotation.setFromQuaternion(tempGroup.quaternion); 
                        });
                        this.scene.remove(tempGroup);
                        if (onComplete) onComplete();
                    }
                };
                animate();
            }

            /**
             * Defines and executes the sequence of animations (solve and then re-scramble).
             */
            spinSolveThenRevert() {
                const solveSeq = [
                    { type: 'horizontal', layer:  1, degrees: -180 },
                    { type: 'vertical',   layer:  1, degrees: -90 },
                    { type: 'vertical',   layer:  0, degrees: -270 },
                    { type: 'horizontal', layer: -1, degrees: -180 },
                    { type: 'vertical',   layer: -1, degrees: -90 }
                ].reverse(); // Reverse to get the solve sequence

                const forwardSeq = [
                    { type: 'vertical',   layer: -1, degrees: 90 },
                    { type: 'horizontal', layer: -1, degrees: 180 },
                    { type: 'vertical',   layer:  0, degrees: 270 },
                    { type: 'vertical',   layer:  1, degrees: 90 },
                    { type: 'horizontal', layer:  1, degrees: 180 }
                ];

                let i = 0;
                const nextMove = (sequence, onFinish) => {
                    if (i >= sequence.length) {
                        if (onFinish) onFinish();
                        return;
                    }
                    const move = sequence[i++];
                    const duration = 1500;
                    const axis = (move.type === 'vertical') ? 'x' : 'y';
                    this.animateLayerRotation(axis, move.layer, move.degrees, duration, () => nextMove(sequence, onFinish));
                };

                // Chain the animations: solve, then re-scramble
                const startSolve = () => {
                    i = 0;
                    nextMove(solveSeq, startForward);
                }

                const startForward = () => {
                    i = 0;
                    setTimeout(() => nextMove(forwardSeq, startSolve), 2000); // Pause before re-scrambling
                }
                
                startSolve(); // Start the first sequence
            }

            /**
             * Starts the main render loop.
             */
            startAnimation() {
                const renderLoop = () => {
                    requestAnimationFrame(renderLoop);
                    // Add a slow continuous rotation to the whole group for visual appeal
                    if (this.cubeGroup) {
                        this.cubeGroup.rotation.y += 0.001;
                        this.cubeGroup.rotation.x += 0.0005;
                    }
                    this.renderer.render(this.scene, this.camera);
                };
                renderLoop();
            }
        }

        // Initialize the class once the window has loaded
        window.addEventListener('load', () => {
            new RubiksCube();
        });
    </script>
</body>
</html>
